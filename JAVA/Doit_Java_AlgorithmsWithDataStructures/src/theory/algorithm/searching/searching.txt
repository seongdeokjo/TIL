검색 알고리즘 : 데이터 집합에서 원하는 값을 가진 요소를 찾아낸는 검색 알고리즘 
		 
	
	ex) 주소록을 검색하는 경우
		1. 국적이 한국인 사람을 찾는다.
		2. 나이가 21세 이상 27세 미만인 사람을 찾는다.
		3. 찾으려는 이름과 가장 비슷한 이름의 사람을 찾는다.
		키(key) : 주목하는 항목 / 데이터의 '일부'
			1. 키 값과 일치하도록 지정(한국)
			2. 키 값의 구간을 지정(21세 이상 27세 미만)
			3. 키 값과 비슷하도록 지정(발음이 가장 비슷한 이름) 
		이런 조건은 하나만 지정하기도 하지만 논리곱이나 논리합을 사용하여 복합해서 지정하기도 한다.

검색 알고리즘의 종류 :
1. 선형 검색(linear search) or 순차 검색(sequential search) : 
		- 무작위로 늘어놓은 데이터 모임에서 검색을 수행
		- 요소가 직선 모양으로 늘어선 배열에서의 검색은 원하는 키 값을 갖는 요소를 만날 때까지 맨 앞부터 순서대로 요소를 검색
		- 종료 조건 : 1. 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우 // 판단 횟수 n+1회
				   	2. 검색할 값과 같은 요소를 발견한 경우			// 판단 횟수 n회
		* 따라서 1.+2.의 판단 횟수는 평균 n / 2 회이다.
	1.1 보초법(sentinel method) : 검색하기 전에 검색하고자 하는 키 값을 맨 끝 요소에 저장하는 값 
								- 원하는 값이 원래의 데이터에 존재하지 않아도 보초인 맨 끝 요소까지 검색하면 종료 조건2가 성립한다.
								  이렇게 하면 원하는 키 값을 찾지 못했을 때를 판단하는 종료조건 1이 없어도 되기 때문에 반복문에서 종료 판단 횟수를 2회에서 1회로 줄이는 역활을 한다.				 
2. 이진 검색 : 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행

3. 해시법 : 추가,삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행
		- 체인법 : 같은 해시 값의 데이터를 선형 리스트로 연결하는 방법
		- 오픈 주소법 : 데이터를 위한 해시 값이 충돌할 때 재해시하는 방법					

알고리즘의 선택 : 계산 시간이 짧은 것을 선택 하지만 데이터 집합에 대한 검색뿐 아니라 데이터의 추가,삭제등을 자주하는 경우라면 검색 이외의 작업에 소요되는 비용을 종합적으로 평가하여 알고리즘을 선택한다.
		  	 *데이터 추가를 자주하는 경우에는 검색이 빠르더라도 데이터의 추가 비용이 많이 들어가는 알고리즘은 피해야 한다.
		  	 **데이터 추가 비용이 많이 든다? :	
				- ex) 학생의 번호 순서대로 키(height)의 값을 넣은 배열이 있다고 가정, 학생의 번호만 알면 바로 키(height)값을 알 수 있다. 
				하지만 새로운 학생이 전학을 와서 중간에 데이터를 끼워 넣어야 할 경우라면 이후의 학생을 모두 뒤로 밀어 넣는 작업을 해야 한다. 이런 경우 
				'배열 검색은 빠르지만 데이터를 추가하기 위한 비용이 많이 든다'라고 한다.		  			