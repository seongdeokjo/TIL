정렬 : 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업이다.

정렬 알고리즘의 안정성 : 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지된다.
	
	내부 정렬(internal sorting) : 하나의 배열에서 작업할 수 있는 경우
	외부 정렬(external sorting) : 하나의 배열에서 작업할 수 없는 경우
정렬 알고리즘의 핵심 요소 : 교환, 선택, 삽입 
	* 오름 차순 정렬 : 왼쪽의 값이 오른쪽의 값보다 작아야 한다. ex) 1,2,3,4,5
	* 내림 차순 정렬 : 왼쪽의 값이 오른쪽의 값보다 커야 한다.	ex) 5,4,3,2,1

1. 버블 정렬 : 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복한다.	
			- 요소의 개수가 n개인 배열에서 n-1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다.
			- 이러 일련의 과정(비교,교환 작업)을 패스(pass)라고 한다. 
			- 비교 횟수의 평균값 : (n-1)+(n-2)+....+1 = n(n-1) / 2
			- 교환 횟수의 평균값 : 비교 횟수의 절반인 n(n-1) / 4회 이지만 메서드 안에서의 값의 이동이 3회 발생하므로 이동 횟수의 평균은 3n(n-1) / 4회 이다.
			
2. 단순 선택 정렬(straight selection sort) : 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘
			- 1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min]) 을 선택
			- 2. (a[min])과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환
			- 비교 횟수 : (n^2 - n) / 2회 ** 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 못하다.
			
3. 단순 삽입 정렬(straight insertion sort) : 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하여 정렬하는 알고리즘
										 **단순 선택 정렬과 비슷하게 보일 수 있지만 단순 선택 정렬은 값이 가장 작은 요소를 선택해 알맞은 위치로 옮긴다는 점이 다르다.
			- 정렬된 부분과 아직 정렬되지 않은 부분에서 배열이 다시 구성된다고 생각한다.
			- 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입한다. -> (n - 1)회 반복하면 정렬을 마치게 된다.
			- 요소의 비교 횟수와 교환 횟수 : n^2 / 2회
			- 1. 정렬된 열의 왼쪽 끝에 도달.
			- 2. tmp보다 작거나 같은 key를 갖는 항목 a[j]를 발견
			- 이때 드모르간 법칙을 적용하면 아래의 두 조건이 모두 성립할 때까지 반복
			- 1-1. j가 0보다 크다.
			- 1-2. a[j - 1]값이 tmp보다 크다.
			- 특징 : 
				1. 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라진다.
				2. 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아진다.
위 3가지의 시간 복잡도(버블,선택,삽입) : O(N^2)

4. 셸 정렬 : 단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정렬하는 알고리즘이다.
			- 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법이다.
			- 흐름 : 셸 정렬 과정에서 수행하는 각각의 정렬을 'h정렬'이라고 한다.
4.1 시간 복잡도 : O(N^1.25)로, 기존의 시간 복잡도인 O(N^2)에 비해 빠르지만, 멀리 떨어져 있는 요소를 교환해야 하므로 안정적이지는 않다.

5. 퀵 정렬 : 가장 빠른 정렬 알고리즘 중의 하나로 널리 사용되고 있다.
			- 피벗(pivot) : 그룹을 나누는 기준(마음대로 선택 가능)
			- 배열을 두 그룹으로 나누기 : 
				피벗x, 왼쪽 끝의 요소의 인덱스 pl을 왼쪽 커서, 오른쪽 끝 요소의 인덱스 pr을 오른쪽 커서라고 지정
				그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮긴다. 
				그 때의 조건 : 1. a[pl] >= x가 성립하는 요소를 찾을 때까지 pl을 오른쪽(->>)으로 스캔한다.
							2. a[pr] <= x가 성립하는 요소를 찾을 때까지 pr을 왼쪽(<<<-)으로 스캔한다.
				이 떄 pl이 위치한 지점은 피벗값 이상의 요소가 있는 지점이고, pr이 위치한 지점은 피벗값 이하의 요소가 있는 지점이다.
				왼쪽(pl)과 오른쪽(pr) 커서가 가리키는 요소 a[pl]과 a[pr]의 값을 교환한다.
				그러면 피벗 이하의 값은 왼쪽으로 피벗 이상의 값은 오른쪽으로 이동한다.
				이 과정을 계속 진행하면 두 커서(pl,pr)가 교차하게 된다. -> 그룹을 나누는 과정이 끝나고 배열은 두 그룹으로 나누어진다.
				피벗 이하의 그룹 : a[0],...,a[pl - 1]
				피벗 이상의 그룹 : a[pr + 1],....,a[n - 1]
				if) pl > pr + 1인 경우
				피벗과 일치하는 값을 가지는 그룹 : a[pr + 1],.....,a[pl -1]
				동일한 요소를 교환 -> 동일한 요소를 교환하는 시도가 의미 없어 보이지만 이 시도는 아무리 많아야 1회이므로 해도 괜찮다.
								 만약 이런 의미 없어 보이는 시도를 줄이기 위해 같은 요소를 교환하지 않는다면 요소를 교환하기 전에
								 'pl,pr이 동일한 요소 위에 있는지' 매번 검사해야 한다.
			- 알고리즘 적용 : 
				요소의 개수가 1개인 그룹은 더 이상 그룹을 나눌 필요가 없으므로 요소의 개수가 2개 이상인 그룹만 나누면 된다.
				1. pr이 a[0]보다 오른쪽에 있으면(left < pr) 왼쪽 그룹을 나눈다.
				2. pl이 a[8]보다 왼쪽에 있으면(pl < right) 오른쪽 그룹을 나눈다.
				* 가운데 그룹(a[pr + 1] ~ a[pl - 1])은 나눌 필요가 없다.(분할 대상에서 제외)
				** left < pr, pl < right는 모두 그룹의 개수가 1개인 경우에는 성립하지 않는 조건이다. 요소의 개수가 2개 이상인 그룹만이 나누기 위해 필요한 조건이다.
			- 피벗 선택하기 :
				방법 1. 나눌 배열의 요소 개수가 3 이상이면 임의로 요소 3을 선택하고, 그 중에서 중앙값인 요소를 피벗으로 선택한다.
				방법 2. 나눌 배열의 처음, 가운데, 끝 요소를 정렬한 다음 가운데 요소와 끝에서 두 번째 요소를 교환한다.
					   피벗으로 끝에서 두 번째 요소의 값(a[right - 1])을 선택하여 나눌 대상의 범위를 a[left + 1] ~ a[right - 2]로 좁힌다. 	
			- 시간 복잡도 : O(N logN) 이지만, 저렬할 배열의 초깃값이나 피벗의 선택 방법에 따라 시간 복잡도가 증가하는 경우도 있다.
						ex) 매번 단 하나의 요소와 나머지 요소로 나누어지면 n번의 분할이 필요하다. 따라서 최악의 시간 복잡도는 O(N^2)	

6. 병합 정렬(merge sort) : 배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음 병합하는 작업을 반복하여 정렬을 수행하는 알고리즘이다.
			- 병합에 필요한 시간 복잡도 : O(N) , 데이터의 요소 개수가 n개일 때, 병합 정렬의 단계는 log n만큼 필요하므로
			- 배열 병합의 전체 시간 복잡도 : O(N logN)
			- 서로 떨어져 있는 요소를 교환하는 것이 아니므로 안정적인 정렬 방법이라고 할 수 있다.
			- 병합 정렬 알고리즘의 순서 : 
				배열의 요소 개수가 2개 이상인 경우
					1. 배열의 앞부분을 병합 정렬로 정렬한다.
					2. 배열의 뒷부분을 병합 정렬로 정렬한다.
					3. 배열의 앞부분과 뒷부분을 병합한다.	
					
7. 힙 정렬(heap sort) : 선택 정렬을 응용한 알고리즘인 힙 정렬은 힙의 특성을 이용하여 정렬을 수행한다.
					  힙은 '부모의 값이 자식의 값보다 항상 크다'는 조건을 만족하는 완전이진트리이다. 이때 부모의 값이 자식보다 항상 작아도 힙이라고 한다.(부모와 자식 요소의 관계만 일정하면 된다.)
					  *트리란? 트리의 가장 윗부분을 루드(root)라고 한다. 그리고 요소의 상하 관계를 '부모(parent)'와 '자식(child)'이라고 한다. 그리고 자식 간의 관계는 '형제(sibling)'라고 한다.
					  *완전이진트리란 트리의 한 종류를 말하며 트리의 종류도 여러가지 인데, 완전이진트리의 특징은 '완전이진'상태라는 것이다. 
					   여기서 '완전'이라는 말은 부모는 자식을 왼쪽부터 추가하는 모양을 유지한다는 뜻이다. 그리고 '이진'이라는 말은 '부모가 가질 수 있는 자식의 개수는 최대 2개다'라는 의미이다.
					  *힙은 형제의 대소 관계가 정해져 있지 않은 특성이 있기 때문에 부분순서트리(partial ordered tree)라고도 한다.
					  - 부모와 자식의 인덱스 사이의 관계 :
					  		1. 부모는 a[(i - 1) / 2]
					  		2. 왼쪽자식은 a[i * 2 + 1]
					  		3. 오른쪽 자식은 a[i * 2 + 2]
					 - 힙 정렬의 특징 : '가장 큰 값이 루트에 위치'하는 특징이 있다.
					 			  - 힙에서 가장 큰 값인 루트를 꺼내는 작업을 반복하고 그 값을 늘어놓으면 배열은 정렬을 마치게 된다.
					 			  - 힙에서 가장 큰 값인 루트를 꺼내고 남은 요소에서 다시 가장 큰 값을 구해야 한다.
					 - 힙 상태 유지 순서 : 
					 		1. 루트를 꺼낸다.
					 		2. 마지막 요소를 루트로 이동한다.
					 		3. 자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복한다.
					 		   이때 자식의 값이 작거나 잎에 다다르면 작업이 종료된다.
					 - 힙 정렬 수행 순서 :
					 		1. 변수 i의 값을 n - 1로 초기화한다.
					 		2. a[0]과 a[i]를 바꾼다.
					 		3. a[0], a[1], ... , a[i - 1]을 힙으로 만든다.
					 		4. i의 값을 1씩 줄여 0이 되면 끝이 난다. 그렇지 않으면 '2'로 돌아간다.
					 - 힙 정렬의 시간 복잡도 : 힙으로 만드는 작업을 요소의 개수만큼 반복하므로 O(N * logN)이다.

8. 도수 정렬 : 요소의 대소 관계를 판단하지 않고 빠르게 정렬할 수 있는 알고리즘이다.
			- 특징 : 요소를 비교할 필요가 없다.
					단일 for문만을 사용하여 재귀 호출, 이중 for문이 없어 아주 효율적이다.
					하지만 도수분포표가 필요하기 때문에 데이터의 최솟값과 최댓값을 미리 알고 있는 경우에만 사용할 수 있다.
			- 단계 : 
				1. 도수분포표 작성
				2. 누적도수분포표 작성
				3. 목적 배열 만들기
				4. 배열 복사					 				   			  		
					   								 			
										 						