정렬 : 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업이다.

정렬 알고리즘의 안정성 : 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지된다.
	
	내부 정렬(internal sorting) : 하나의 배열에서 작업할 수 있는 경우
	외부 정렬(external sorting) : 하나의 배열에서 작업할 수 없는 경우
정렬 알고리즘의 핵심 요소 : 교환, 선택, 삽입 
	* 오름 차순 정렬 : 왼쪽의 값이 오른쪽의 값보다 작아야 한다. ex) 1,2,3,4,5
	* 내림 차순 정렬 : 왼쪽의 값이 오른쪽의 값보다 커야 한다.	ex) 5,4,3,2,1

1. 버블 정렬 : 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복한다.	
			- 요소의 개수가 n개인 배열에서 n-1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다.
			- 이러 일련의 과정(비교,교환 작업)을 패스(pass)라고 한다. 
			- 비교 횟수의 평균값 : (n-1)+(n-2)+....+1 = n(n-1) / 2
			- 교환 횟수의 평균값 : 비교 횟수의 절반인 n(n-1) / 4회 이지만 메서드 안에서의 값의 이동이 3회 발생하므로 이동 횟수의 평균은 3n(n-1) / 4회 이다.
2. 단순 선택 정렬(straight selection sort) : 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘
			- 1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min]) 을 선택
			- 2. (a[min])과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환
			- 비교 횟수 : (n^2 - n) / 2회 ** 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 못하다.
3. 단순 삽입 정렬(straight insertion sort) : 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하여 정렬하는 알고리즘
										 **단순 선택 정렬과 비슷하게 보일 수 있지만 단순 선택 정렬은 값이 가장 작은 요소를 선택해 알맞은 위치로 옮긴다는 점이 다르다.
			- 정렬된 부분과 아직 정렬되지 않은 부분에서 배열이 다시 구성된다고 생각한다.
			- 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입한다. -> (n - 1)회 반복하면 정렬을 마치게 된다.
			- 요소의 비교 횟수와 교환 횟수 : n^2 / 2회
			- 1. 정렬된 열의 왼쪽 끝에 도달.
			- 2. tmp보다 작거나 같은 key를 갖는 항목 a[j]를 발견
			- 이때 드모르간 법칙을 적용하면 아래의 두 조건이 모두 성립할 때까지 반복
			- 1-1. j가 0보다 크다.
			- 1-2. a[j - 1]값이 tmp보다 크다.
			- 특징 : 
				1. 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라진다.
				2. 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아진다.
위 3가지의 시간 복잡도(버블,선택,삽입) : O(N^2)

4. 셸 정렬 : 단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정렬하는 알고리즘이다.
			- 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법이다.
			- 흐름 : 셸 정렬 과정에서 수행하는 각각의 정렬을 'h정렬'이라고 한다.
4.1 시간 복잡도 : O(N^1.25)로, 기존의 시간 복잡도인 O(N^2)에 비해 빠르지만, 멀리 떨어져 있는 요소를 교환해야 하므로 안정적이지는 않다.		
										 						