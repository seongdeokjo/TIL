정렬 : 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업이다.

정렬 알고리즘의 안정성 : 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지된다.
	
	내부 정렬(internal sorting) : 하나의 배열에서 작업할 수 있는 경우
	외부 정렬(external sorting) : 하나의 배열에서 작업할 수 없는 경우
정렬 알고리즘의 핵심 요소 : 교환, 선택, 삽입 
	* 오름 차순 정렬 : 왼쪽의 값이 오른쪽의 값보다 작아야 한다. ex) 1,2,3,4,5
	* 내림 차순 정렬 : 왼쪽의 값이 오른쪽의 값보다 커야 한다.	ex) 5,4,3,2,1

1. 버블 정렬 : 이웃한 두 요소의 대소 관계를 비교하여 교환을 반복한다.	
			- 요소의 개수가 n개인 배열에서 n-1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다.
			- 이러 일련의 과정(비교,교환 작업)을 패스(pass)라고 한다. 
			- 비교 횟수의 평균값 : (n-1)+(n-2)+....+1 = n(n-1) / 2
			- 교환 횟수의 평균값 : 비교 횟수의 절반인 n(n-1) / 4회 이지만 메서드 안에서의 값의 이동이 3회 발생하므로 이동 횟수의 평균은 3n(n-1) / 4회 이다.
			
2. 단순 선택 정렬(straight selection sort) : 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘
			- 1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min]) 을 선택
			- 2. (a[min])과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환
			- 비교 횟수 : (n^2 - n) / 2회 ** 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 못하다.
			
3. 단순 삽입 정렬(straight insertion sort) : 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하여 정렬하는 알고리즘
										 **단순 선택 정렬과 비슷하게 보일 수 있지만 단순 선택 정렬은 값이 가장 작은 요소를 선택해 알맞은 위치로 옮긴다는 점이 다르다.
			- 정렬된 부분과 아직 정렬되지 않은 부분에서 배열이 다시 구성된다고 생각한다.
			- 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입한다. -> (n - 1)회 반복하면 정렬을 마치게 된다.
			- 요소의 비교 횟수와 교환 횟수 : n^2 / 2회
			- 1. 정렬된 열의 왼쪽 끝에 도달.
			- 2. tmp보다 작거나 같은 key를 갖는 항목 a[j]를 발견
			- 이때 드모르간 법칙을 적용하면 아래의 두 조건이 모두 성립할 때까지 반복
			- 1-1. j가 0보다 크다.
			- 1-2. a[j - 1]값이 tmp보다 크다.
			- 특징 : 
				1. 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라진다.
				2. 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아진다.
위 3가지의 시간 복잡도(버블,선택,삽입) : O(N^2)

4. 셸 정렬 : 단순 삽입 정렬의 장점은 살리고 단점은 보완하여 좀 더 빠르게 정렬하는 알고리즘이다.
			- 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행하고, 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법이다.
			- 흐름 : 셸 정렬 과정에서 수행하는 각각의 정렬을 'h정렬'이라고 한다.
4.1 시간 복잡도 : O(N^1.25)로, 기존의 시간 복잡도인 O(N^2)에 비해 빠르지만, 멀리 떨어져 있는 요소를 교환해야 하므로 안정적이지는 않다.

5. 퀵 정렬 : 가장 빠른 정렬 알고리즘 중의 하나로 널리 사용되고 있다.
			- 피벗(pivot) : 그룹을 나누는 기준(마음대로 선택 가능)
			- 배열을 두 그룹으로 나누기 : 
				피벗x, 왼쪽 끝의 요소의 인덱스 pl을 왼쪽 커서, 오른쪽 끝 요소의 인덱스 pr을 오른쪽 커서라고 지정
				그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮긴다. 
				그 때의 조건 : 1. a[pl] >= x가 성립하는 요소를 찾을 때까지 pl을 오른쪽(->>)으로 스캔한다.
							2. a[pr] <= x가 성립하는 요소를 찾을 때까지 pr을 왼쪽(<<<-)으로 스캔한다.
				이 떄 pl이 위치한 지점은 피벗값 이상의 요소가 있는 지점이고, pr이 위치한 지점은 피벗값 이하의 요소가 있는 지점이다.
				왼쪽(pl)과 오른쪽(pr) 커서가 가리키는 요소 a[pl]과 a[pr]의 값을 교환한다.
				그러면 피벗 이하의 값은 왼쪽으로 피벗 이상의 값은 오른쪽으로 이동한다.
				이 과정을 계속 진행하면 두 커서(pl,pr)가 교차하게 된다. -> 그룹을 나누는 과정이 끝나고 배열은 두 그룹으로 나누어진다.
				피벗 이하의 그룹 : a[0],...,a[pl - 1]
				피벗 이상의 그룹 : a[pr + 1],....,a[n - 1]
				if) pl > pr + 1인 경우
				피벗과 일치하는 값을 가지는 그룹 : a[pr + 1],.....,a[pl -1]
				동일한 요소를 교환 -> 동일한 요소를 교환하는 시도가 의미 없어 보이지만 이 시도는 아무리 많아야 1회이므로 해도 괜찮다.
								 만약 이런 의미 없어 보이는 시도를 줄이기 위해 같은 요소를 교환하지 않는다면 요소를 교환하기 전에
								 'pl,pr이 동일한 요소 위에 있는지' 매번 검사해야 한다.
			- 알고리즘 적용 : 
				요소의 개수가 1개인 그룹은 더 이상 그룹을 나눌 필요가 없으므로 요소의 개수가 2개 이상인 그룹만 나누면 된다.
				1. pr이 a[0]보다 오른쪽에 있으면(left < pr) 왼쪽 그룹을 나눈다.
				2. pl이 a[8]보다 왼쪽에 있으면(pl < right) 오른쪽 그룹을 나눈다.
				* 가운데 그룹(a[pr + 1] ~ a[pl - 1])은 나눌 필요가 없다.(분할 대상에서 제외)
				** left < pr, pl < right는 모두 그룹의 개수가 1개인 경우에는 성립하지 않는 조건이다. 요소의 개수가 2개 이상인 그룹만이 나누기 위해 필요한 조건이다.
			- 피벗 선택하기 :
				방법 1. 나눌 배열의 요소 개수가 3 이상이면 임의로 요소 3을 선택하고, 그 중에서 중앙값인 요소를 피벗으로 선택한다.
				방법 2. 나눌 배열의 처음, 가운데, 끝 요소를 정렬한 다음 가운데 요소와 끝에서 두 번째 요소를 교환한다.
					   피벗으로 끝에서 두 번째 요소의 값(a[right - 1])을 선택하여 나눌 대상의 범위를 a[left + 1] ~ a[right - 2]로 좁힌다. 	
			- 시간 복잡도 : O(N logN) 이지만, 저렬할 배열의 초깃값이나 피벗의 선택 방법에 따라 시간 복잡도가 증가하는 경우도 있다.
						ex) 매번 단 하나의 요소와 나머지 요소로 나누어지면 n번의 분할이 필요하다. 따라서 최악의 시간 복잡도는 O(N^2)	

6. 병합 정렬(merge sort) : 배열을 앞부분과 뒷부분으로 나누어 각각 정렬한 다음 병합하는 작업을 반복하여 정렬을 수행하는 알고리즘이다.
			- 병합에 필요한 시간 복잡도 : O(N) , 데이터의 요소 개수가 n개일 때, 병합 정렬의 단계는 log n만큼 필요하므로
			- 배열 병합의 전체 시간 복잡도 : O(N logN)
			- 서로 떨어져 있는 요소를 교환하는 것이 아니므로 안정적인 정렬 방법이라고 할 수 있다.
			- 병합 정렬 알고리즘의 순서 : 
				배열의 요소 개수가 2개 이상인 경우
					1. 배열의 앞부분을 병합 정렬로 정렬한다.
					2. 배열의 뒷부분을 병합 정렬로 정렬한다.
					3. 배열의 앞부분과 뒷부분을 병합한다.				 			
										 						