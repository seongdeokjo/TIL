클래스 :
	1.클래스 본체와 멤버 :
			- 멤버(필드/메서드/중첩(nested)클래스/중첩(nested)인터페이스)
			- 클래스 초기화 / 인스턴스 초기화
			- 생성자
	2. 필드/메서드/생성자를 선언할 때 public/protected/private을 지정할 수 있다.
	3. 메서드/생성자는 다중으로 정의(오버로드)할 수 있다. // 오버로드란? 메서드나 생성자를 정의할 때 형식은 다르지만 같은 이름을 붙이는 것
	4. final로 선언한 필드는 한 번만 값을 대입할 수 있다.
	5. 생성자는 새로 생성한 인스턴스의 초기화를 위해 사용

	공개 클래스 : 클래스 접근 제한자 public을 붙여 선언한 클래스로, 다른 패키지에서 사용할 수 있는 공개 클래스(public class)
	final 클래스 : 클래스 접근 제한자 final을 붙여 선언한 클래스로, 서브 클래스를 가질 수 없다.(새로운 클래스를 상속할 수 없다.)
	파생 클래스 : 클래스 A를 직접 상위 클래스(direct superclass)로 하려면 선언할 때 extends A를 추가해야 한다.
			   이 때 선언한 클래스는 클래스 A의 직접 서브 클래스(direct subclass)가 된다.
			   클래스 선언에 extends가 없는 클래스의 상위 클래스는 Object 클래스가 된다.
	추상 클래스 : 클래스 접근 제한자 abstract를 붙여 클래스를 선언하면 추상 메서드를 가질 수 있는 추상 클래스(abstract class)가 된다.
			   추상 클래스형은 불완전한 클래스이므로 인스턴스를 만들 수 없다.
			   추상 메서드란? 실체가 정의되지 않은 메서드, 실체는 서브 클래스에서 정의
	중첩 클래스 : 클래스 또는 인터페이스 안에 선언한 클래스 (nested class)
			   멤버 클래스(member class)는 그 선언이 다른 클래스 또는 인터페이스 선언에 둘러싸인 클래스
			   내부 클래스(inner class)는 명시적으로도 암묵적으로도 정적(static)으로 선언되지 않는 중첩 클래스, 정적 초기화나 멤버 인터페이스 선언을 할 수 없다.
			   그리고 컴파일을 할 때 상수 필드가 아닌 한 정적 멤버를 선언할 수 없다.
			   지역 클래스(local class)는 이름이 주어진 중첩 클래스인 내부 클래스이다. 어떤 클래스의 멤버도 될 수 없다.		   		   

	인터페이스 구현 : 인터페이스 x를 구현하려면 선언에 implements x를 추가해야 한다.	
	
	클래스 메서드 : 정적 메서드 -> static을 붙여 선언한 메서드, 클래스 전체에 대한 처리를 담당 / 호출 시 : 클래스형 변수 이름.메서드 이름
	인스턴스 메서드 : 비정적 메서드 -> static을 붙이지 않고 선언한 메서드 / 호출 시 : 클래스 이름.메서드 이름
	 
제네릭 : 처리해야 할 대상의 자료형에 의존하지 않는 클래스(인터페이스) 구현 방식
	제네릭 클래스 : 자료형에 의존하지 않기 때문에 범용으로 사용가능
	사용 방법 : 파라미터를 쉼표로 구분하면 파라미터 여러 개 지정 가능
		class 클래스 이름 <파라미터1,파라미터2, ....> { /*... */}
		interface 인터페이스 이름 <파라미터1, 파라미터2, ....> { /*... */}
		정의된 클래스나 인터페이스는 매개변수로 정의한 '자료형'을 전달 받을 수 있다.
	파라미터 이름 작성 방법 : 
		1. 1개의 대문자를 사용(소문자는 가급적 사용하지 않는다.)
		2. 컬렉션(collection)의 자료형은 element의 앞글자인 E를 사용
		3. 맵(map)의 키(key), 값(value)은 key와value의 앞글자인 K와V를 사용
		4. 일반적으로는 T를 사용
		*또한 형변수에는 와일드 카드를 지정하는 것도 가능하다.
		<? extends T> : 클래스 T의 서브클래스를 전달 받는다.
		<? super T> : 클래스 T의 슈퍼 클래스를 전달 받는다.
		ex) class GenericClassTester{
				// 제네릭 클래스의 파라미터를 T라고 작성
				static class GenericClass<T>{
					private T xyz;
					GenericClass(T t) {    // 생성자
						this.xyz = t;
					}
					T getXyz(){
						return xyz; // xyz를 반환
					}
				}
				public static void main(String[] args){
					// 파라미터에 String을 넘길 수도 있고 Integer를 넘길 수도 있다.
					GenericClass<String> s = new GenericClass<String>("abc");
					GenericClass<Integer> n = new GenericClass<Integer>(15);
					
					System.out.println(s.getXyz() + " " + n.getXyz()); // abc 15 출력
				}
		}			