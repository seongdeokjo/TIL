#include <stdio.h>

// 퀵 정렬 : 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눈다 ,하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬 
// 시간 복잡도 :  O(N * logN) 
/*
ex) [1] => 3 7 8 1 5 9 6 10 2 4 -> 맨처음 3이 피벗 값 
			피벗 값을 기준으로 왼- > 오  피벗 값 보다 큰 값을 찾는다 : 7  
							 오 -> 왼  피벗 값 보다 작은 값을 찾는다 : 2
							  
	[2] : (3) 2 8 1 5 9 6 10 7 4 다시 [1] 반복
	[3] : (3) 2 1 8 5 9 6 10 7 4 
	[4] : (3) 2 1 8 5 9 6 10 7 4 -> 찾는 도중 작은 값의 인덱스가 큰 값의 인덱스보다 더 작은 경우 엇갈렸다 고 표현
	[5] : 1 2 3 8 5 9 6 10 7 4 -> 엇갈린 상황에서 왼쪽에 있는 값과 서로 자리를 바꿈
	[6] : 1 2 <= (3) => 8 5 9 6 10 7 4 ->  피벗 값 기준으로 분할 
	 									왼쪽은 피벗 값 기준으로 작은 값 
										오른쪽은 피벗 값 기준으로 큰 값
	[7] : (1) 2 3 (8) 5 9 6 10 7 4	-> 각각 피벗값 기준으로 다시 반복									 
	[8] : 1 2 3 (8) 5 9 6 10 7 4 -> 왼쪽 부분 정렬 수행 완료 
	[9] : 1 2 3  | (8) 5 4 6 10 7 9
	[10] : 1 2 3 | (8) 5 4 6 7 10 9 -> 엇갈림 
	[11] : 1 2 3 | (7) 5 4 6 <= (8) => (10) 9
	[12] : 1 2 3 | 6 5 4 (7) | 8 (10) 9 
	[13] : 1 2 3 | (6) 5 4 7 | 8 (10) 9
	[14] : 1 2 3 | (4) 5 6 7 | 8 (10) 9
	[15] : 1 2 3 4 5 6 7 | 8 (9) 10
	[16] : 1 2 3 4 5 6 7 8 9 10 -> 정렬 완료  
	
*/

int number = 10;
int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
void quickSort(int *data, int start, int end){
	if(start >= end){ // 원소가 1개인 경우 
		return;
	}
	
	int key = start; // 키는 첫번째 원소
	int i = start + 1; // 왼 -> 오 : 큰 값을 찾기 위해 
	int j = end;	// 오 -> 왼  : 작은 값을 찾기 위해 
	int temp;
	// 오름 차순 정렬 | 내림차순 정렬은  
	while(i <= j){ // 엇갈릴 때까지 반복 data[i] <= data[key] -> >= , data[j] >= data[key] && j > start -> <= 
		while(data[i] <= data[key]){ // 키 값보다 큰 값을 만날 때 까지 오른쪽으로 이동 
				i++;
		}
		while(data[j] >= data[key] && j > start){ // 키 값보다 작은 값을 만날 때 까지 왼쪽으로 이동 
			j--;
		}
		if(i > j){ // 현재 엇갈린 상태면 키 값과 교체 
			temp = data[j];
			data[j] = data[key];
			data[key] = temp;
		}else{
			temp = data[j];
			data[j] = data[i];
			data[i] = temp;
		}
		
	} 
	
	quickSort(data, start, j -1);
	quickSort(data, j+1, end);
	
}

int main(void){
	
	quickSort(data,0, number - 1);
	for(int i = 0; i< number; i++){
		printf("%d ", data[i]);
	}			
}
